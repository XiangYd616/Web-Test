#!/usr/bin/env node

/**
 * ÊúçÂä°‰æùËµñÂàÜÊûêÂ∑•ÂÖ∑
 * ÂàÜÊûêÊúçÂä°Áº∫Â§±ÊòØÂê¶Áî±ÈîôËØØÊàñÁº∫Â§±ÂØºÂÖ•ÈÄ†Êàê
 */

const fs = require('fs');
const path = require('path');

class ServiceDependencyAnalyzer {
  constructor() {
    this.projectRoot = process.cwd();
    this.existingServices = new Map();
    this.missingServices = new Map();
    this.brokenImports = [];
    this.serviceMapping = new Map();
    this.statistics = {
      totalFiles: 0,
      existingServices: 0,
      missingServices: 0,
      brokenImports: 0,
      fixableIssues: 0
    };
  }

  /**
   * ÊâßË°åÂàÜÊûê
   */
  async execute() {
    console.log('üîç ÂºÄÂßãÊúçÂä°‰æùËµñÂàÜÊûê...\n');

    try {
      // 1. Êâ´ÊèèÁé∞ÊúâÊúçÂä°
      await this.scanExistingServices();
      
      // 2. ÂàÜÊûêÁº∫Â§±ÁöÑÊúçÂä°ÂØºÂÖ•
      await this.analyzeMissingServices();
      
      // 3. Âª∫Á´ãÊúçÂä°Êò†Â∞ÑÂÖ≥Á≥ª
      await this.buildServiceMapping();
      
      // 4. ÁîüÊàêÂàÜÊûêÊä•Âëä
      this.generateReport();
      
    } catch (error) {
      console.error('‚ùå ÂàÜÊûêËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:', error);
      throw error;
    }
  }

  /**
   * Êâ´ÊèèÁé∞ÊúâÊúçÂä°
   */
  async scanExistingServices() {
    console.log('üìÇ Êâ´ÊèèÁé∞ÊúâÊúçÂä°Êñá‰ª∂...');

    const serviceDirectories = [
      'frontend/services',
      'backend/services',
      'backend/engines',
      'frontend/hooks',
      'frontend/utils',
      'backend/utils'
    ];

    serviceDirectories.forEach(dir => {
      const fullPath = path.join(this.projectRoot, dir);
      if (fs.existsSync(fullPath)) {
        this.scanDirectory(fullPath, 'existing');
      }
    });

    console.log(`   ÂèëÁé∞ ${this.existingServices.size} ‰∏™Áé∞ÊúâÊúçÂä°Êñá‰ª∂\n`);
  }

  /**
   * ÂàÜÊûêÁº∫Â§±ÁöÑÊúçÂä°ÂØºÂÖ•
   */
  async analyzeMissingServices() {
    console.log('üîç ÂàÜÊûêÁº∫Â§±ÁöÑÊúçÂä°ÂØºÂÖ•...');

    const files = this.getCodeFiles();
    
    for (const file of files) {
      await this.analyzeFile(file);
    }

    console.log(`   ÂèëÁé∞ ${this.brokenImports.length} ‰∏™Áº∫Â§±ÊúçÂä°ÂØºÂÖ•\n`);
  }

  /**
   * ÂàÜÊûêÂçï‰∏™Êñá‰ª∂
   */
  async analyzeFile(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      this.statistics.totalFiles++;
      
      // ÊèêÂèñÂØºÂÖ•ËØ≠Âè•
      const imports = this.extractImports(content);
      
      for (const importInfo of imports) {
        if (this.isServiceImport(importInfo.path)) {
          const resolvedPath = this.resolveImportPath(filePath, importInfo.path);
          
          if (!this.fileExists(resolvedPath)) {
            this.brokenImports.push({
              file: filePath,
              importPath: importInfo.path,
              resolvedPath,
              importStatement: importInfo.fullMatch,
              serviceName: this.extractServiceName(importInfo.path),
              category: this.categorizeService(importInfo.path)
            });
            this.statistics.brokenImports++;
          }
        }
      }
      
    } catch (error) {
      // ÂøΩÁï•Êó†Ê≥ïËØªÂèñÁöÑÊñá‰ª∂
    }
  }

  /**
   * ÊèêÂèñÂØºÂÖ•ËØ≠Âè•
   */
  extractImports(content) {
    const imports = [];
    const patterns = [
      /import\s+(?:(?:\{[^}]*\}|\*\s+as\s+\w+|\w+)\s+from\s+)?['"`]([^'"`]+)['"`]/g,
      /require\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g
    ];

    patterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        imports.push({
          fullMatch: match[0],
          path: match[1]
        });
      }
    });

    return imports;
  }

  /**
   * Âà§Êñ≠ÊòØÂê¶‰∏∫ÊúçÂä°ÂØºÂÖ•
   */
  isServiceImport(importPath) {
    const servicePatterns = [
      /services\//,
      /engines\//,
      /hooks\/use/,
      /utils\//,
      /Service$/,
      /Engine$/,
      /Manager$/,
      /Handler$/,
      /Client$/,
      /Analyzer$/
    ];

    return servicePatterns.some(pattern => pattern.test(importPath)) && 
           importPath.startsWith('.'); // Âè™Ê£ÄÊü•Áõ∏ÂØπË∑ØÂæÑ
  }

  /**
   * ÊèêÂèñÊúçÂä°ÂêçÁß∞
   */
  extractServiceName(importPath) {
    const parts = importPath.split('/');
    const fileName = parts[parts.length - 1];
    return fileName.replace(/\.(ts|js|tsx|jsx)$/, '');
  }

  /**
   * ÂàÜÁ±ªÊúçÂä°
   */
  categorizeService(importPath) {
    if (importPath.includes('/services/')) {
      if (importPath.includes('/auth/')) return 'auth';
      if (importPath.includes('/testing/')) return 'testing';
      if (importPath.includes('/data/')) return 'data';
      if (importPath.includes('/realtime/')) return 'realtime';
      if (importPath.includes('/config/')) return 'config';
      if (importPath.includes('/analytics/')) return 'analytics';
      if (importPath.includes('/reporting/')) return 'reporting';
      return 'service';
    }
    if (importPath.includes('/engines/')) return 'engine';
    if (importPath.includes('/hooks/')) return 'hook';
    if (importPath.includes('/utils/')) return 'utility';
    return 'unknown';
  }

  /**
   * Âª∫Á´ãÊúçÂä°Êò†Â∞ÑÂÖ≥Á≥ª
   */
  async buildServiceMapping() {
    console.log('üîó Âª∫Á´ãÊúçÂä°Êò†Â∞ÑÂÖ≥Á≥ª...');

    // ÂàÜÊûêÁº∫Â§±ÊúçÂä°‰∏éÁé∞ÊúâÊúçÂä°ÁöÑÂÖ≥Á≥ª
    this.brokenImports.forEach(brokenImport => {
      const serviceName = brokenImport.serviceName;
      const category = brokenImport.category;
      
      // Êü•ÊâæÂèØËÉΩÁöÑÊõø‰ª£ÊúçÂä°
      const alternatives = this.findAlternativeServices(serviceName, category);
      
      if (alternatives.length > 0) {
        this.serviceMapping.set(brokenImport.importPath, alternatives);
        this.statistics.fixableIssues++;
      }
    });

    console.log(`   Âª∫Á´ã ${this.serviceMapping.size} ‰∏™ÊúçÂä°Êò†Â∞ÑÂÖ≥Á≥ª\n`);
  }

  /**
   * Êü•ÊâæÊõø‰ª£ÊúçÂä°
   */
  findAlternativeServices(serviceName, category) {
    const alternatives = [];
    
    // Âü∫‰∫éÂêçÁß∞Áõ∏‰ººÊÄßÊü•Êâæ
    for (const [existingPath, existingInfo] of this.existingServices) {
      const existingName = existingInfo.name.toLowerCase();
      const targetName = serviceName.toLowerCase();
      
      // ÂêçÁß∞ÂåÖÂê´ÂÖ≥Á≥ª
      if (existingName.includes(targetName) || targetName.includes(existingName)) {
        alternatives.push({
          path: existingPath,
          name: existingInfo.name,
          similarity: this.calculateSimilarity(targetName, existingName),
          reason: 'name_similarity'
        });
      }
      
      // ÂäüËÉΩÁõ∏‰ººÊÄß
      if (existingInfo.category === category) {
        const functionalSimilarity = this.calculateFunctionalSimilarity(serviceName, existingInfo.name);
        if (functionalSimilarity > 0.3) {
          alternatives.push({
            path: existingPath,
            name: existingInfo.name,
            similarity: functionalSimilarity,
            reason: 'functional_similarity'
          });
        }
      }
    }
    
    // ÊåâÁõ∏‰ººÂ∫¶ÊéíÂ∫è
    return alternatives.sort((a, b) => b.similarity - a.similarity).slice(0, 3);
  }

  /**
   * ËÆ°ÁÆóÂêçÁß∞Áõ∏‰ººÂ∫¶
   */
  calculateSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = this.levenshteinDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
  }

  /**
   * ËÆ°ÁÆóÂäüËÉΩÁõ∏‰ººÂ∫¶
   */
  calculateFunctionalSimilarity(name1, name2) {
    const keywords1 = this.extractKeywords(name1);
    const keywords2 = this.extractKeywords(name2);
    
    const intersection = keywords1.filter(k => keywords2.includes(k));
    const union = [...new Set([...keywords1, ...keywords2])];
    
    return union.length > 0 ? intersection.length / union.length : 0;
  }

  /**
   * ÊèêÂèñÂÖ≥ÈîÆËØç
   */
  extractKeywords(name) {
    const keywords = [];
    
    // È©ºÂ≥∞ÂëΩÂêçÂàÜÂâ≤
    const camelCaseWords = name.split(/(?=[A-Z])/).map(w => w.toLowerCase());
    keywords.push(...camelCaseWords);
    
    // ‰∏ãÂàíÁ∫øÂàÜÂâ≤
    const underscoreWords = name.split('_').map(w => w.toLowerCase());
    keywords.push(...underscoreWords);
    
    // ÂäüËÉΩÂÖ≥ÈîÆËØç
    const functionalKeywords = ['test', 'service', 'manager', 'engine', 'analyzer', 'client', 'handler'];
    keywords.push(...functionalKeywords.filter(k => name.toLowerCase().includes(k)));
    
    return [...new Set(keywords)].filter(k => k.length > 2);
  }

  /**
   * ËÆ°ÁÆóÁºñËæëË∑ùÁ¶ª
   */
  levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  /**
   * Êâ´ÊèèÁõÆÂΩï
   */
  scanDirectory(dir, type) {
    if (!fs.existsSync(dir)) return;
    
    const items = fs.readdirSync(dir);
    
    items.forEach(item => {
      if (this.shouldSkipDirectory(item)) return;
      
      const fullPath = path.join(dir, item);
      
      try {
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          this.scanDirectory(fullPath, type);
        } else if (/\.(ts|tsx|js|jsx)$/.test(item) && !this.shouldSkipFile(item)) {
          const relativePath = path.relative(this.projectRoot, fullPath);
          const serviceName = path.basename(item, path.extname(item));
          const category = this.categorizeService(relativePath);
          
          if (type === 'existing') {
            this.existingServices.set(relativePath, {
              name: serviceName,
              category,
              path: fullPath
            });
            this.statistics.existingServices++;
          }
        }
      } catch (error) {
        // ÂøΩÁï•Êó†Ê≥ïËÆøÈóÆÁöÑÊñá‰ª∂
      }
    });
  }

  /**
   * Ëß£ÊûêÂØºÂÖ•Ë∑ØÂæÑ
   */
  resolveImportPath(filePath, importPath) {
    const fileDir = path.dirname(filePath);
    let resolvedPath = path.resolve(fileDir, importPath);
    
    // Â∞ùËØï‰∏çÂêåÁöÑÊâ©Â±ïÂêç
    const extensions = ['.ts', '.tsx', '.js', '.jsx'];
    for (const ext of extensions) {
      if (fs.existsSync(resolvedPath + ext)) {
        return resolvedPath + ext;
      }
    }
    
    // Ê£ÄÊü•indexÊñá‰ª∂
    for (const ext of extensions) {
      const indexPath = path.join(resolvedPath, 'index' + ext);
      if (fs.existsSync(indexPath)) {
        return indexPath;
      }
    }
    
    return resolvedPath;
  }

  /**
   * Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
   */
  fileExists(filePath) {
    try {
      return fs.existsSync(filePath) && fs.statSync(filePath).isFile();
    } catch (error) {
      return false;
    }
  }

  /**
   * Ëé∑Âèñ‰ª£Á†ÅÊñá‰ª∂
   */
  getCodeFiles() {
    const files = [];
    
    const scanDirectory = (dir) => {
      if (!fs.existsSync(dir)) return;
      
      const items = fs.readdirSync(dir);
      
      items.forEach(item => {
        if (this.shouldSkipDirectory(item)) return;
        
        const fullPath = path.join(dir, item);
        
        try {
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory()) {
            scanDirectory(fullPath);
          } else if (/\.(ts|tsx|js|jsx)$/.test(item) && !this.shouldSkipFile(item)) {
            files.push(fullPath);
          }
        } catch (error) {
          // ÂøΩÁï•Êó†Ê≥ïËÆøÈóÆÁöÑÊñá‰ª∂
        }
      });
    };
    
    scanDirectory(path.join(this.projectRoot, 'frontend'));
    scanDirectory(path.join(this.projectRoot, 'backend'));
    
    return files;
  }

  shouldSkipFile(fileName) {
    const skipPatterns = [
      /\.(test|spec)\./,
      /\.stories\./,
      /node_modules/,
      /dist/,
      /build/
    ];
    
    return skipPatterns.some(pattern => pattern.test(fileName));
  }

  shouldSkipDirectory(dirName) {
    const skipDirs = ['node_modules', '.git', 'dist', 'build', '.next', '.vite', 'backup'];
    return skipDirs.includes(dirName) || dirName.startsWith('.');
  }

  /**
   * ÁîüÊàêÂàÜÊûêÊä•Âëä
   */
  generateReport() {
    console.log('üìä ÊúçÂä°‰æùËµñÂàÜÊûêÊä•Âëä');
    console.log('='.repeat(60));
    
    console.log(`Ê£ÄÊü•Êñá‰ª∂: ${this.statistics.totalFiles}`);
    console.log(`Áé∞ÊúâÊúçÂä°: ${this.statistics.existingServices}`);
    console.log(`Áº∫Â§±ÊúçÂä°ÂØºÂÖ•: ${this.statistics.brokenImports}`);
    console.log(`ÂèØ‰øÆÂ§çÈóÆÈ¢ò: ${this.statistics.fixableIssues}`);
    console.log(`‰øÆÂ§çÊàêÂäüÁéá: ${this.statistics.brokenImports > 0 ? (this.statistics.fixableIssues / this.statistics.brokenImports * 100).toFixed(1) : 0}%`);

    if (this.brokenImports.length === 0) {
      console.log('\n‚úÖ Ê≤°ÊúâÂèëÁé∞ÊúçÂä°ÂØºÂÖ•ÈóÆÈ¢òÔºÅ');
      return;
    }

    // ÊåâÁ±ªÂà´ÂàÜÁªÑÊòæÁ§∫Áº∫Â§±ÊúçÂä°
    const servicesByCategory = {};
    this.brokenImports.forEach(item => {
      if (!servicesByCategory[item.category]) {
        servicesByCategory[item.category] = [];
      }
      servicesByCategory[item.category].push(item);
    });

    console.log('\nüìã Áº∫Â§±ÊúçÂä°ÂàÜÊûê:');
    Object.entries(servicesByCategory).forEach(([category, services]) => {
      console.log(`\n${this.getCategoryDisplayName(category)} (${services.length}‰∏™):`);
      
      services.slice(0, 5).forEach(service => {
        console.log(`   ‚ùå ${service.serviceName}`);
        console.log(`      Ë∑ØÂæÑ: ${service.importPath}`);
        console.log(`      Êñá‰ª∂: ${path.relative(this.projectRoot, service.file)}`);
        
        // ÊòæÁ§∫ÂèØËÉΩÁöÑÊõø‰ª£ÊñπÊ°à
        const alternatives = this.serviceMapping.get(service.importPath);
        if (alternatives && alternatives.length > 0) {
          console.log(`      üí° Âª∫ËÆÆÊõø‰ª£:`);
          alternatives.slice(0, 2).forEach(alt => {
            console.log(`         ‚Üí ${alt.name} (Áõ∏‰ººÂ∫¶: ${(alt.similarity * 100).toFixed(0)}%)`);
          });
        }
      });
      
      if (services.length > 5) {
        console.log(`   ... ËøòÊúâ ${services.length - 5} ‰∏™Á±ª‰ººÈóÆÈ¢ò`);
      }
    });

    console.log('\nüîß ‰øÆÂ§çÂª∫ËÆÆ:');
    
    if (this.statistics.fixableIssues > 0) {
      console.log(`\n1. ÂèØËá™Âä®‰øÆÂ§çÁöÑÈóÆÈ¢ò (${this.statistics.fixableIssues}‰∏™):`);
      console.log('   - ‰ΩøÁî®Áé∞ÊúâÁöÑÁõ∏‰ººÊúçÂä°Êõø‰ª£');
      console.log('   - ÈáçÂÆöÂêëÂà∞ÂäüËÉΩÁõ∏ËøëÁöÑÊúçÂä°');
    }
    
    const unfixableIssues = this.statistics.brokenImports - this.statistics.fixableIssues;
    if (unfixableIssues > 0) {
      console.log(`\n2. ÈúÄË¶ÅÊâãÂä®Â§ÑÁêÜÁöÑÈóÆÈ¢ò (${unfixableIssues}‰∏™):`);
      console.log('   - ÂàõÂª∫Áº∫Â§±ÁöÑÊúçÂä°Êñá‰ª∂');
      console.log('   - Âà†Èô§‰∏çÈúÄË¶ÅÁöÑÂØºÂÖ•');
      console.log('   - ÈáçÊñ∞ËÆæËÆ°ÊúçÂä°Êû∂ÊûÑ');
    }

    console.log('\nüìà Áé∞ÊúâÊúçÂä°ÁªüËÆ°:');
    const existingByCategory = {};
    for (const [path, info] of this.existingServices) {
      if (!existingByCategory[info.category]) {
        existingByCategory[info.category] = 0;
      }
      existingByCategory[info.category]++;
    }
    
    Object.entries(existingByCategory).forEach(([category, count]) => {
      console.log(`   ${this.getCategoryDisplayName(category)}: ${count}‰∏™`);
    });

    console.log('\nüí° ‰∏ã‰∏ÄÊ≠•Ë°åÂä®:');
    console.log('1. ËøêË°åËá™Âä®‰øÆÂ§çÂ∑•ÂÖ∑Â§ÑÁêÜÂèØ‰øÆÂ§çÁöÑÈóÆÈ¢ò');
    console.log('2. Ê†πÊçÆ‰∏öÂä°ÈúÄÊ±ÇÂàõÂª∫Áº∫Â§±ÁöÑÊ†∏ÂøÉÊúçÂä°');
    console.log('3. Ê∏ÖÁêÜ‰∏çÈúÄË¶ÅÁöÑÊúçÂä°ÂØºÂÖ•');
    console.log('4. ÈáçÊñ∞ËøêË°å‰æùËµñÂàÜÊûêÈ™åËØÅ‰øÆÂ§çÊïàÊûú');
  }

  getCategoryDisplayName(category) {
    const categoryNames = {
      auth: 'ËÆ§ËØÅÊúçÂä°',
      testing: 'ÊµãËØïÊúçÂä°',
      data: 'Êï∞ÊçÆÊúçÂä°',
      realtime: 'ÂÆûÊó∂ÊúçÂä°',
      config: 'ÈÖçÁΩÆÊúçÂä°',
      analytics: 'ÂàÜÊûêÊúçÂä°',
      reporting: 'Êä•ÂëäÊúçÂä°',
      service: 'ÈÄöÁî®ÊúçÂä°',
      engine: 'ÂºïÊìéÁªÑ‰ª∂',
      hook: 'React Hooks',
      utility: 'Â∑•ÂÖ∑ÂáΩÊï∞',
      unknown: 'Êú™ÂàÜÁ±ª'
    };
    
    return categoryNames[category] || category;
  }
}

// ÊâßË°åÂàÜÊûê
if (require.main === module) {
  const analyzer = new ServiceDependencyAnalyzer();
  analyzer.execute().catch(console.error);
}

module.exports = ServiceDependencyAnalyzer;
