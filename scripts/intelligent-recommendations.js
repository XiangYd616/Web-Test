#!/usr/bin/env node
/**
 * Test-Web Êô∫ËÉΩÊé®ËçêÂºïÊìé
 * Êèê‰æõ‰ª£Á†Å‰ºòÂåñÂª∫ËÆÆ„ÄÅÊúÄ‰Ω≥ÂÆûË∑µÊé®ËçêÂíåÈóÆÈ¢òËß£ÂÜ≥ÊñπÊ°à
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// È¢úËâ≤ÂÆö‰πâ
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

// Êó•ÂøóÂáΩÊï∞
const log = (message, color = 'reset') => {
  console.log(`${colors[color]}${message}${colors.reset}`);
};

class IntelligentRecommendationEngine {
  constructor() {
    this.projectRoot = process.cwd();
    this.recommendations = [];
    this.projectAnalysis = {};
  }

  // ÂàÜÊûêÈ°πÁõÆÁªìÊûÑ
  analyzeProject() {
    log('üîç ÂàÜÊûêÈ°πÁõÆÁªìÊûÑ...', 'cyan');

    const packageJsonPath = path.join(this.projectRoot, 'package.json');
    const tsConfigPath = path.join(this.projectRoot, 'tsconfig.json');
    const frontendPath = path.join(this.projectRoot, 'frontend');
    const backendPath = path.join(this.projectRoot, 'backend');

    this.projectAnalysis = {
      hasPackageJson: fs.existsSync(packageJsonPath),
      hasTsConfig: fs.existsSync(tsConfigPath),
      hasFrontend: fs.existsSync(frontendPath),
      hasBackend: fs.existsSync(backendPath),
      isMonorepo: fs.existsSync(frontendPath) && fs.existsSync(backendPath),
      packageJson: null,
      tsConfig: null,
    };

    if (this.projectAnalysis.hasPackageJson) {
      try {
        this.projectAnalysis.packageJson = JSON.parse(
          fs.readFileSync(packageJsonPath, 'utf8')
        );
      } catch (error) {
        log('‚ö†Ô∏è  Êó†Ê≥ïËß£Êûê package.json', 'yellow');
      }
    }

    if (this.projectAnalysis.hasTsConfig) {
      try {
        const tsConfigContent = fs.readFileSync(tsConfigPath, 'utf8');
        // ÁÆÄÂçïËß£ÊûêÔºåÂøΩÁï•Ê≥®Èáä
        const cleanContent = tsConfigContent.replace(/\/\*[\s\S]*?\*\/|\/\/.*$/gm, '');
        this.projectAnalysis.tsConfig = JSON.parse(cleanContent);
      } catch (error) {
        log('‚ö†Ô∏è  Êó†Ê≥ïËß£Êûê tsconfig.json', 'yellow');
      }
    }

    log('‚úÖ È°πÁõÆÁªìÊûÑÂàÜÊûêÂÆåÊàê', 'green');
  }

  // Ê£ÄÊü•‰ª£Á†ÅË¥®Èáè
  checkCodeQuality() {
    log('üîç Ê£ÄÊü•‰ª£Á†ÅË¥®Èáè...', 'cyan');

    const checks = [
      this.checkTypeScriptErrors(),
      this.checkESLintIssues(),
      this.checkPrettierFormatting(),
      this.checkTestCoverage(),
      this.checkDependencyVulnerabilities(),
    ];

    return checks.filter(Boolean);
  }

  // TypeScript ÈîôËØØÊ£ÄÊü•
  checkTypeScriptErrors() {
    if (!this.projectAnalysis.hasTsConfig) return null;

    try {
      execSync('npx tsc --noEmit', { stdio: 'ignore' });
      return {
        type: 'success',
        category: 'TypeScript',
        message: 'TypeScript Á±ªÂûãÊ£ÄÊü•ÈÄöËøá',
        recommendation: 'ÁªßÁª≠‰øùÊåÅËâØÂ•ΩÁöÑÁ±ªÂûãÂÆâÂÖ®ÂÆûË∑µ',
      };
    } catch (error) {
      return {
        type: 'error',
        category: 'TypeScript',
        message: 'TypeScript Á±ªÂûãÊ£ÄÊü•Â§±Ë¥•',
        recommendation: 'ËøêË°å `npx tsc --noEmit` Êü•ÁúãËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØÂπ∂‰øÆÂ§ç',
        action: 'npm run type-check',
      };
    }
  }

  // ESLint ÈóÆÈ¢òÊ£ÄÊü•
  checkESLintIssues() {
    const eslintConfigPath = path.join(this.projectRoot, '.eslintrc.js');
    if (!fs.existsSync(eslintConfigPath)) {
      return {
        type: 'warning',
        category: 'ESLint',
        message: 'Êú™ÊâæÂà∞ ESLint ÈÖçÁΩÆÊñá‰ª∂',
        recommendation: 'Âª∫ËÆÆÊ∑ªÂä† ESLint ÈÖçÁΩÆ‰ª•‰øùÊåÅ‰ª£Á†ÅË¥®Èáè',
        action: 'ÂàõÂª∫ .eslintrc.js ÈÖçÁΩÆÊñá‰ª∂',
      };
    }

    try {
      execSync('npx eslint . --ext .ts,.tsx,.js,.jsx --quiet', { stdio: 'ignore' });
      return {
        type: 'success',
        category: 'ESLint',
        message: 'ESLint Ê£ÄÊü•ÈÄöËøá',
        recommendation: '‰ª£Á†ÅÁ¨¶Âêà ESLint ËßÑËåÉ',
      };
    } catch (error) {
      return {
        type: 'warning',
        category: 'ESLint',
        message: 'ESLint ÂèëÁé∞‰ª£Á†ÅË¥®ÈáèÈóÆÈ¢ò',
        recommendation: 'ËøêË°å `npm run lint:fix` Ëá™Âä®‰øÆÂ§çÂèØ‰øÆÂ§çÁöÑÈóÆÈ¢ò',
        action: 'npm run lint:fix',
      };
    }
  }

  // Prettier Ê†ºÂºèÊ£ÄÊü•
  checkPrettierFormatting() {
    const prettierConfigPath = path.join(this.projectRoot, '.prettierrc');
    if (!fs.existsSync(prettierConfigPath)) {
      return {
        type: 'info',
        category: 'Prettier',
        message: 'Âª∫ËÆÆÊ∑ªÂä† Prettier ÈÖçÁΩÆ',
        recommendation: 'Áªü‰∏ÄÁöÑ‰ª£Á†ÅÊ†ºÂºèÊúâÂä©‰∫éÂõ¢ÈòüÂçè‰Ωú',
      };
    }

    try {
      execSync('npx prettier --check "**/*.{ts,tsx,js,jsx}"', { stdio: 'ignore' });
      return {
        type: 'success',
        category: 'Prettier',
        message: '‰ª£Á†ÅÊ†ºÂºèÊ£ÄÊü•ÈÄöËøá',
        recommendation: '‰ª£Á†ÅÊ†ºÂºèÁ¨¶Âêà Prettier ËßÑËåÉ',
      };
    } catch (error) {
      return {
        type: 'info',
        category: 'Prettier',
        message: '‰ª£Á†ÅÊ†ºÂºèÈúÄË¶ÅË∞ÉÊï¥',
        recommendation: 'ËøêË°å `npm run format` Ëá™Âä®Ê†ºÂºèÂåñ‰ª£Á†Å',
        action: 'npm run format',
      };
    }
  }

  // ÊµãËØïË¶ÜÁõñÁéáÊ£ÄÊü•
  checkTestCoverage() {
    const packageJson = this.projectAnalysis.packageJson;
    if (!packageJson || !packageJson.scripts || !packageJson.scripts.test) {
      return {
        type: 'warning',
        category: 'ÊµãËØï',
        message: 'Êú™ÈÖçÁΩÆÊµãËØïËÑöÊú¨',
        recommendation: 'Âª∫ËÆÆÊ∑ªÂä†ÂçïÂÖÉÊµãËØï‰ª•ÊèêÈ´ò‰ª£Á†ÅË¥®Èáè',
      };
    }

    return {
      type: 'info',
      category: 'ÊµãËØï',
      message: 'Â∑≤ÈÖçÁΩÆÊµãËØïËÑöÊú¨',
      recommendation: 'ÂÆöÊúüËøêË°åÊµãËØïÁ°Æ‰øù‰ª£Á†ÅË¥®Èáè',
      action: 'npm test',
    };
  }

  // ‰æùËµñÊºèÊ¥ûÊ£ÄÊü•
  checkDependencyVulnerabilities() {
    try {
      execSync('npm audit --audit-level=moderate', { stdio: 'ignore' });
      return {
        type: 'success',
        category: 'ÂÆâÂÖ®',
        message: '‰æùËµñÂÆâÂÖ®Ê£ÄÊü•ÈÄöËøá',
        recommendation: '‰æùËµñÂåÖÊ≤°ÊúâÂ∑≤Áü•ÁöÑÂÆâÂÖ®ÊºèÊ¥û',
      };
    } catch (error) {
      return {
        type: 'warning',
        category: 'ÂÆâÂÖ®',
        message: 'ÂèëÁé∞‰æùËµñÂÆâÂÖ®ÊºèÊ¥û',
        recommendation: 'ËøêË°å `npm audit fix` ‰øÆÂ§çÂèØËá™Âä®‰øÆÂ§çÁöÑÊºèÊ¥û',
        action: 'npm audit fix',
      };
    }
  }

  // ÁîüÊàêÊÄßËÉΩ‰ºòÂåñÂª∫ËÆÆ
  generatePerformanceRecommendations() {
    const recommendations = [];

    // Ê£ÄÊü• bundle Â§ßÂ∞è
    const distPath = path.join(this.projectRoot, 'dist');
    if (fs.existsSync(distPath)) {
      recommendations.push({
        type: 'info',
        category: 'ÊÄßËÉΩ',
        message: 'Âª∫ËÆÆÂàÜÊûêÊâìÂåÖ‰ΩìÁßØ',
        recommendation: '‰ΩøÁî® webpack-bundle-analyzer ÂàÜÊûêÊâìÂåÖ‰ΩìÁßØ',
        action: 'npx webpack-bundle-analyzer dist/static/js/*.js',
      });
    }

    // Ê£ÄÊü•ÂõæÁâá‰ºòÂåñ
    const publicPath = path.join(this.projectRoot, 'public');
    if (fs.existsSync(publicPath)) {
      recommendations.push({
        type: 'info',
        category: 'ÊÄßËÉΩ',
        message: 'Âª∫ËÆÆ‰ºòÂåñÈùôÊÄÅËµÑÊ∫ê',
        recommendation: 'ÂéãÁº©ÂõæÁâáÂíå‰ΩøÁî®Áé∞‰ª£ÂõæÁâáÊ†ºÂºè (WebP, AVIF)',
      });
    }

    return recommendations;
  }

  // ÁîüÊàêÊúÄ‰Ω≥ÂÆûË∑µÂª∫ËÆÆ
  generateBestPracticeRecommendations() {
    const recommendations = [];

    // Ê£ÄÊü• Git hooks
    const preCommitHook = path.join(this.projectRoot, '.git/hooks/pre-commit');
    if (!fs.existsSync(preCommitHook)) {
      recommendations.push({
        type: 'info',
        category: 'ÊúÄ‰Ω≥ÂÆûË∑µ',
        message: 'Âª∫ËÆÆÊ∑ªÂä† Git pre-commit hook',
        recommendation: 'Ëá™Âä®ËøêË°å‰ª£Á†ÅÊ£ÄÊü•ÔºåÈò≤Ê≠¢ÊúâÈóÆÈ¢òÁöÑ‰ª£Á†ÅÊèê‰∫§',
      });
    }

    // Ê£ÄÊü• README
    const readmePath = path.join(this.projectRoot, 'README.md');
    if (!fs.existsSync(readmePath)) {
      recommendations.push({
        type: 'warning',
        category: 'ÊñáÊ°£',
        message: 'Áº∫Â∞ë README.md Êñá‰ª∂',
        recommendation: 'Ê∑ªÂä†È°πÁõÆËØ¥ÊòéÊñáÊ°£ÔºåÂåÖÊã¨ÂÆâË£ÖÂíå‰ΩøÁî®ÊåáÂçó',
      });
    }

    // Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆ
    const envExamplePath = path.join(this.projectRoot, '.env.example');
    if (!fs.existsSync(envExamplePath)) {
      recommendations.push({
        type: 'info',
        category: 'ÈÖçÁΩÆ',
        message: 'Âª∫ËÆÆÊ∑ªÂä† .env.example Êñá‰ª∂',
        recommendation: 'Êèê‰æõÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆÁ§∫‰æãÔºåÊñπ‰æøÂÖ∂‰ªñÂºÄÂèëËÄÖËÆæÁΩÆ',
      });
    }

    return recommendations;
  }

  // ËæìÂá∫Êé®ËçêÊä•Âëä
  generateReport() {
    log('\nüìä ÁîüÊàêÊô∫ËÉΩÊé®ËçêÊä•Âëä...', 'cyan');

    const allRecommendations = [
      ...this.checkCodeQuality(),
      ...this.generatePerformanceRecommendations(),
      ...this.generateBestPracticeRecommendations(),
    ];

    // ÊåâÁ±ªÂûãÂàÜÁªÑ
    const groupedRecommendations = allRecommendations.reduce((groups, rec) => {
      const type = rec.type;
      if (!groups[type]) groups[type] = [];
      groups[type].push(rec);
      return groups;
    }, {});

    // ËæìÂá∫Êä•Âëä
    log('\nüéØ Êô∫ËÉΩÊé®ËçêÊä•Âëä', 'bright');
    log('='.repeat(50), 'cyan');

    // ÊàêÂäüÈ°π
    if (groupedRecommendations.success) {
      log('\n‚úÖ ÂÅöÂæóÂæàÂ•Ω:', 'green');
      groupedRecommendations.success.forEach(rec => {
        log(`  ‚Ä¢ ${rec.category}: ${rec.message}`, 'green');
      });
    }

    // Ë≠¶ÂëäÈ°π
    if (groupedRecommendations.warning) {
      log('\n‚ö†Ô∏è  ÈúÄË¶ÅÊ≥®ÊÑè:', 'yellow');
      groupedRecommendations.warning.forEach(rec => {
        log(`  ‚Ä¢ ${rec.category}: ${rec.message}`, 'yellow');
        log(`    Êé®Ëçê: ${rec.recommendation}`, 'reset');
        if (rec.action) {
          log(`    ÊâßË°å: ${rec.action}`, 'cyan');
        }
      });
    }

    // ÈîôËØØÈ°π
    if (groupedRecommendations.error) {
      log('\n‚ùå ÈúÄË¶Å‰øÆÂ§ç:', 'red');
      groupedRecommendations.error.forEach(rec => {
        log(`  ‚Ä¢ ${rec.category}: ${rec.message}`, 'red');
        log(`    Êé®Ëçê: ${rec.recommendation}`, 'reset');
        if (rec.action) {
          log(`    ÊâßË°å: ${rec.action}`, 'cyan');
        }
      });
    }

    // ‰ø°ÊÅØÈ°π
    if (groupedRecommendations.info) {
      log('\nüí° ‰ºòÂåñÂª∫ËÆÆ:', 'blue');
      groupedRecommendations.info.forEach(rec => {
        log(`  ‚Ä¢ ${rec.category}: ${rec.message}`, 'blue');
        log(`    Êé®Ëçê: ${rec.recommendation}`, 'reset');
        if (rec.action) {
          log(`    ÊâßË°å: ${rec.action}`, 'cyan');
        }
      });
    }

    // ‰øùÂ≠òÊä•ÂëäÂà∞Êñá‰ª∂
    const reportPath = path.join(this.projectRoot, 'intelligent-recommendations-report.json');
    const report = {
      timestamp: new Date().toISOString(),
      projectAnalysis: this.projectAnalysis,
      recommendations: allRecommendations,
      summary: {
        total: allRecommendations.length,
        success: groupedRecommendations.success?.length || 0,
        warning: groupedRecommendations.warning?.length || 0,
        error: groupedRecommendations.error?.length || 0,
        info: groupedRecommendations.info?.length || 0,
      },
    };

    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    log(`\nüìÑ ËØ¶ÁªÜÊä•ÂëäÂ∑≤‰øùÂ≠òÂà∞: ${reportPath}`, 'cyan');

    return report;
  }

  // ËøêË°åÊô∫ËÉΩÊé®ËçêÂºïÊìé
  run() {
    log('üß† ÂêØÂä®Êô∫ËÉΩÊé®ËçêÂºïÊìé...', 'magenta');

    this.analyzeProject();
    const report = this.generateReport();

    log('\nüéâ Êô∫ËÉΩÊé®ËçêÂºïÊìéËøêË°åÂÆåÊàê!', 'green');

    return report;
  }
}

// ‰∏ªÂáΩÊï∞
function main() {
  const engine = new IntelligentRecommendationEngine();
  return engine.run();
}

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§ËÑöÊú¨
if (require.main === module) {
  main();
}

module.exports = IntelligentRecommendationEngine;
