/**
 * AnalyticsÁõ∏ÂÖ≥ÈáçÂ§çÊñá‰ª∂Ê∏ÖÁêÜÂô®
 * ‰∏ìÈó®Â§ÑÁêÜAnalyticsÁõ∏ÂÖ≥ÁöÑÈáçÂ§çÊñá‰ª∂ÁâàÊú¨ÈóÆÈ¢ò
 */

const fs = require('fs');
const path = require('path');

class AnalyticsDuplicateCleaner {
  constructor() {
    this.projectRoot = process.cwd();
    this.backupDir = path.join(this.projectRoot, 'backup', 'analytics-cleanup');
    this.dryRun = process.argv.includes('--dry-run');

    // ÂÆö‰πâAnalyticsÁõ∏ÂÖ≥ÁöÑÈáçÂ§çÊñá‰ª∂
    this.analyticsDuplicates = [
      {
        category: 'AnalyticsÁªÑ‰ª∂',
        files: [
          {
            path: 'frontend/components/analytics/Analytics.tsx',
            keep: true,
            reason: 'È´òÁ∫ßÂàÜÊûêÁªÑ‰ª∂ÔºåÂäüËÉΩÂÆåÊï¥ÔºåÂåÖÂê´Ë∂ãÂäøÂàÜÊûê„ÄÅÂØπÊØîÂàÜÊûêÁ≠â'
          },
          {
            path: 'frontend/pages/data/reports/Analytics.tsx',
            keep: false,
            reason: 'ÁÆÄÂåñÁâàÊú¨ÔºåÂäüËÉΩÈáçÂ§ç'
          }
        ],
        targetName: 'frontend/components/analytics/Analytics.tsx',
        risk: 'medium'
      },
      {
        category: 'AnalyticsPageÈ°µÈù¢',
        files: [
          {
            path: 'frontend/pages/analytics/AnalyticsPage.tsx',
            keep: true,
            reason: 'ÂÆåÊï¥ÁöÑÂàÜÊûêÈ°µÈù¢ÔºåÂåÖÂê´Â§öÁßçÊï∞ÊçÆÁ±ªÂûãÂíåÊó∂Èó¥ËåÉÂõ¥ÈÄâÊã©'
          }
        ],
        targetName: 'frontend/pages/analytics/AnalyticsPage.tsx',
        risk: 'low'
      },
      {
        category: 'AnalyticsOverviewÁªÑ‰ª∂',
        files: [
          {
            path: 'frontend/components/features/AnalyticsOverview.tsx',
            keep: true,
            reason: 'Ê¶ÇËßàÁªÑ‰ª∂ÔºåÊèê‰æõÊï∞ÊçÆÊÄªËßàÂäüËÉΩ'
          }
        ],
        targetName: 'frontend/components/features/AnalyticsOverview.tsx',
        risk: 'low'
      },
      {
        category: 'AnalyticsServiceÊúçÂä°',
        files: [
          {
            path: 'frontend/services/analytics/analyticsService.ts',
            keep: true,
            reason: 'È´òÁ∫ßÂàÜÊûêÊúçÂä°ÔºåÂäüËÉΩÂÆåÊï¥ÔºåÂåÖÂê´ËØ¶ÁªÜÊåáÊ†áÂíåÊ¥ûÂØüÂàÜÊûê'
          },
          {
            path: 'frontend/services/analytics/index.ts',
            keep: false,
            reason: 'Âü∫Á°ÄÁâàÊú¨ÔºåÂäüËÉΩÁõ∏ÂØπÁÆÄÂçï'
          }
        ],
        targetName: 'frontend/services/analytics/analyticsService.ts',
        risk: 'high'
      }
    ];
  }

  /**
   * ÊâßË°åÊ∏ÖÁêÜÊµÅÁ®ã
   */
  async execute() {
    console.log('üîç ÂºÄÂßãAnalyticsÈáçÂ§çÊñá‰ª∂Ê∏ÖÁêÜ...\n');

    if (this.dryRun) {
      console.log('üîç [ËØïËøêË°åÊ®°Âºè] ‰∏ç‰ºöÂÆûÈôÖ‰øÆÊîπÊñá‰ª∂\n');
    }

    // ÂàõÂª∫Â§á‰ªΩÁõÆÂΩï
    this.ensureBackupDirectory();

    // È¶ñÂÖàÂàÜÊûêÊâÄÊúâAnalyticsÁõ∏ÂÖ≥Êñá‰ª∂
    await this.analyzeAnalyticsFiles();

    // Â§ÑÁêÜÊØè‰∏™ÈáçÂ§çÊñá‰ª∂ÁªÑ
    for (const group of this.analyticsDuplicates) {
      await this.processGroup(group);
    }

    // ÁîüÊàêÊ∏ÖÁêÜÊä•Âëä
    this.generateReport();

    console.log('\n‚úÖ AnalyticsÈáçÂ§çÊñá‰ª∂Ê∏ÖÁêÜÂÆåÊàêÔºÅ');
  }

  /**
   * ÂàÜÊûêÊâÄÊúâAnalyticsÁõ∏ÂÖ≥Êñá‰ª∂
   */
  async analyzeAnalyticsFiles() {
    console.log('üìä ÂàÜÊûêAnalyticsÁõ∏ÂÖ≥Êñá‰ª∂...\n');

    const analyticsFiles = this.findAnalyticsFiles();

    console.log(`ÊâæÂà∞ ${analyticsFiles.length} ‰∏™AnalyticsÁõ∏ÂÖ≥Êñá‰ª∂:`);
    analyticsFiles.forEach(file => {
      try {
        const fullPath = path.join(this.projectRoot, file);
        const stat = fs.statSync(fullPath);
        const lines = this.countLines(fullPath);
        console.log(`  üìÑ ${file} (${lines}Ë°å, ${stat.size}Â≠óËäÇ)`);
      } catch (error) {
        console.log(`  ‚ùå ${file} (Êñá‰ª∂‰∏çÂ≠òÂú®ÊàñÊó†Ê≥ïËÆøÈóÆ)`);
      }
    });

    console.log('\n');
  }

  /**
   * Êü•ÊâæÊâÄÊúâAnalyticsÁõ∏ÂÖ≥Êñá‰ª∂
   */
  findAnalyticsFiles() {
    const files = [];

    const scanDirectory = (dir, relativePath = '') => {
      if (!fs.existsSync(dir)) return;

      const items = fs.readdirSync(dir);

      items.forEach(item => {
        if (this.shouldSkipDirectory(item)) return;

        const fullPath = path.join(dir, item);
        const relativeFilePath = path.join(relativePath, item);

        try {
          const stat = fs.statSync(fullPath);

          if (stat.isDirectory()) {
            scanDirectory(fullPath, relativeFilePath);
          } else if (this.isAnalyticsFile(item)) {
            files.push(relativeFilePath.replace(/\\/g, '/'));
          }
        } catch (error) {
          // ÂøΩÁï•Êó†Ê≥ïËÆøÈóÆÁöÑÊñá‰ª∂
        }
      });
    };

    scanDirectory(path.join(this.projectRoot, 'frontend'));
    scanDirectory(path.join(this.projectRoot, 'backend'));

    return files;
  }

  /**
   * Âà§Êñ≠ÊòØÂê¶ÊòØAnalyticsÁõ∏ÂÖ≥Êñá‰ª∂
   */
  isAnalyticsFile(fileName) {
    const analyticsKeywords = [
      'analytics', 'Analytics', 'analysis', 'Analysis'
    ];

    return analyticsKeywords.some(keyword =>
      fileName.toLowerCase().includes(keyword.toLowerCase())
    ) && /\.(ts|tsx|js|jsx)$/.test(fileName);
  }

  /**
   * Â§ÑÁêÜÈáçÂ§çÊñá‰ª∂ÁªÑ
   */
  async processGroup(group) {
    console.log(`\nüìÇ Â§ÑÁêÜÁªÑ: ${group.category}`);
    console.log(`   È£éÈô©Á≠âÁ∫ß: ${group.risk}`);

    // Ê£ÄÊü•ÊâÄÊúâÊñá‰ª∂ÊòØÂê¶Â≠òÂú®
    const existingFiles = group.files.filter(file => {
      const fullPath = path.join(this.projectRoot, file.path);
      const exists = fs.existsSync(fullPath);
      if (!exists) {
        console.log(`   ‚ö†Ô∏è  Êñá‰ª∂‰∏çÂ≠òÂú®: ${file.path}`);
      }
      return exists;
    });

    if (existingFiles.length < 1) {
      console.log(`   ‚ÑπÔ∏è  Ë∑≥ËøáÔºöÊ≤°ÊúâÊñá‰ª∂Â≠òÂú®`);
      return;
    }

    // ÊâæÂà∞Ë¶Å‰øùÁïôÂíåÂà†Èô§ÁöÑÊñá‰ª∂
    const keepFiles = existingFiles.filter(file => file.keep);
    const removeFiles = existingFiles.filter(file => !file.keep);

    if (keepFiles.length === 0) {
      console.log(`   ‚ÑπÔ∏è  Ë∑≥ËøáÔºöÊ≤°ÊúâÊåáÂÆöË¶Å‰øùÁïôÁöÑÊñá‰ª∂`);
      return;
    }

    console.log(`   ‚úÖ ‰øùÁïô ${keepFiles.length} ‰∏™Êñá‰ª∂:`);
    keepFiles.forEach(file => {
      console.log(`     - ${file.path} (${file.reason})`);
    });

    if (removeFiles.length > 0) {
      console.log(`   üóëÔ∏è  Âà†Èô§ ${removeFiles.length} ‰∏™Êñá‰ª∂:`);
      removeFiles.forEach(file => {
        console.log(`     - ${file.path} (${file.reason})`);
      });

      // ÂàÜÊûêÊñá‰ª∂Â∑ÆÂºÇ
      if (existingFiles.length > 1) {
        await this.analyzeFileDifferences(existingFiles);
      }

      // Ê£ÄÊü•ÂºïÁî®
      for (const file of removeFiles) {
        const references = await this.findFileReferences(file.path);
        if (references.length > 0) {
          console.log(`     üìã ${file.path} Ë¢´ ${references.length} ‰∏™Êñá‰ª∂ÂºïÁî®`);
        }
      }

      // ÊâßË°åÊ∏ÖÁêÜ
      if (!this.dryRun) {
        await this.executeCleanup(group, keepFiles[0], removeFiles);
      } else {
        console.log(`   üîç [ËØïËøêË°å] Â∞ÜÂà†Èô§ ${removeFiles.length} ‰∏™ÈáçÂ§çÊñá‰ª∂`);
      }
    } else {
      console.log(`   ‚ÑπÔ∏è  Êó†ÈúÄÂà†Èô§Êñá‰ª∂`);
    }
  }

  /**
   * ÂàÜÊûêÊñá‰ª∂ÂÜÖÂÆπÂ∑ÆÂºÇ
   */
  async analyzeFileDifferences(files) {
    console.log(`     üîç ÂàÜÊûêÊñá‰ª∂Â∑ÆÂºÇ...`);

    files.forEach(file => {
      const fullPath = path.join(this.projectRoot, file.path);
      const stat = fs.statSync(fullPath);
      const lines = this.countLines(fullPath);

      console.log(`       ${file.path}: ${lines}Ë°å, ${stat.size}Â≠óËäÇ, ‰øÆÊîπÊó∂Èó¥: ${stat.mtime.toISOString().split('T')[0]}`);
    });
  }

  /**
   * Êü•ÊâæÊñá‰ª∂ÂºïÁî®
   */
  async findFileReferences(filePath) {
    const references = [];
    const fileName = path.basename(filePath, path.extname(filePath));

    // ÊêúÁ¥¢Ê®°Âºè
    const searchPatterns = [
      new RegExp(`import.*from.*['"\`].*${fileName}.*['"\`]`, 'g'),
      new RegExp(`import.*['"\`].*${fileName}.*['"\`]`, 'g'),
      new RegExp(`require\\(['"\`].*${fileName}.*['"\`]\\)`, 'g')
    ];

    // Êâ´ÊèèÈ°πÁõÆÊñá‰ª∂
    const projectFiles = this.getAllProjectFiles();

    for (const projectFile of projectFiles) {
      if (projectFile === filePath) continue;

      try {
        const fullPath = path.join(this.projectRoot, projectFile);
        const content = fs.readFileSync(fullPath, 'utf8');

        for (const pattern of searchPatterns) {
          if (pattern.test(content)) {
            references.push(projectFile);
            break;
          }
        }
      } catch (error) {
        // ÂøΩÁï•ËØªÂèñÈîôËØØ
      }
    }

    return references;
  }

  /**
   * ÊâßË°åÊ∏ÖÁêÜÊìç‰Ωú
   */
  async executeCleanup(group, keepFile, removeFiles) {
    console.log(`     üßπ ÊâßË°åÊ∏ÖÁêÜÊìç‰Ωú...`);

    for (const removeFile of removeFiles) {
      const sourcePath = path.join(this.projectRoot, removeFile.path);
      const backupPath = path.join(this.backupDir, path.basename(removeFile.path));

      // ÂàõÂª∫Â§á‰ªΩ
      fs.copyFileSync(sourcePath, backupPath);
      console.log(`       üìã Â∑≤Â§á‰ªΩ: ${removeFile.path}`);

      // Âà†Èô§Êñá‰ª∂
      fs.unlinkSync(sourcePath);
      console.log(`       üóëÔ∏è  Â∑≤Âà†Èô§: ${removeFile.path}`);
    }
  }

  /**
   * Â∑•ÂÖ∑ÊñπÊ≥ï
   */
  getAllProjectFiles() {
    const files = [];

    const scanDirectory = (dir, relativePath = '') => {
      if (!fs.existsSync(dir)) return;

      const items = fs.readdirSync(dir);

      items.forEach(item => {
        if (this.shouldSkipDirectory(item)) return;

        const fullPath = path.join(dir, item);
        const relativeFilePath = path.join(relativePath, item);

        try {
          const stat = fs.statSync(fullPath);

          if (stat.isDirectory()) {
            scanDirectory(fullPath, relativeFilePath);
          } else if (/\.(ts|tsx|js|jsx)$/.test(item)) {
            files.push(relativeFilePath.replace(/\\/g, '/'));
          }
        } catch (error) {
          // ÂøΩÁï•Êó†Ê≥ïËÆøÈóÆÁöÑÊñá‰ª∂
        }
      });
    };

    scanDirectory(path.join(this.projectRoot, 'frontend'));
    scanDirectory(path.join(this.projectRoot, 'backend'));

    return files;
  }

  shouldSkipDirectory(dirName) {
    const skipDirs = [
      'node_modules', '.git', 'dist', 'build', 'coverage',
      '__tests__', '.vscode', '.idea', 'temp', 'tmp', 'backup'
    ];
    return skipDirs.includes(dirName) || dirName.startsWith('.');
  }

  countLines(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      return content.split('\n').length;
    } catch {
      return 0;
    }
  }

  ensureBackupDirectory() {
    if (!fs.existsSync(this.backupDir)) {
      fs.mkdirSync(this.backupDir, { recursive: true });
    }
  }

  /**
   * ÁîüÊàêÊ∏ÖÁêÜÊä•Âëä
   */
  generateReport() {
    const reportPath = path.join(this.projectRoot, 'analytics-cleanup-report.json');
    const report = {
      timestamp: new Date().toISOString(),
      dryRun: this.dryRun,
      summary: {
        totalGroups: this.analyticsDuplicates.length,
        processedGroups: this.analyticsDuplicates.length
      },
      groups: this.analyticsDuplicates.map(group => ({
        category: group.category,
        risk: group.risk,
        files: group.files.map(f => ({
          path: f.path,
          keep: f.keep,
          reason: f.reason
        }))
      }))
    };

    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

    console.log('\nüìä Ê∏ÖÁêÜÊä•Âëä:');
    console.log(`   Â§ÑÁêÜÁªÑÊï∞: ${report.summary.totalGroups}`);
    console.log(`   Êä•ÂëäÂ∑≤‰øùÂ≠ò: ${reportPath}`);
  }
}

// ÊâßË°åÊ∏ÖÁêÜ
if (require.main === module) {
  const cleaner = new AnalyticsDuplicateCleaner();
  cleaner.execute().catch(console.error);
}

module.exports = AnalyticsDuplicateCleaner;
