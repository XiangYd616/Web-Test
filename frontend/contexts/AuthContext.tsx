import React from 'react';
import { createContext, useContext, useEffect, useState } from 'react';
import type { ReactNode, FC } from 'react';;
import { parseAuthError } from '../components/auth/AuthErrorHandler';
import type { AuthContextType, User } from '../types/auth.types';

interface LoginCredentials {
  email: string;
  password: string;
  rememberMe?: boolean;
}

interface RegisterData {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [refreshTimer, setRefreshTimer] = useState<NodeJS.Timeout | null>(null);

  // TokenËá™Âä®Âà∑Êñ∞ÂäüËÉΩ
  const setupTokenRefresh = (expiresIn: number) => {
    // Âú®tokenËøáÊúüÂâç5ÂàÜÈíüÂà∑Êñ∞
    const refreshTime = Math.max(expiresIn - 5 * 60 * 1000, 60 * 1000);

    if (refreshTimer) {
      clearTimeout(refreshTimer);
    }

    const timer = setTimeout(async () => {
      try {
        await refreshToken();
      } catch (error) {
        console.error('Ëá™Âä®Âà∑Êñ∞tokenÂ§±Ë¥•:', error);
        await logout();
      }
    }, refreshTime);

    setRefreshTimer(timer);
  };

  // Ëß£ÊûêJWT tokenËé∑ÂèñËøáÊúüÊó∂Èó¥
  const parseTokenExpiry = (token: string): number => {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp * 1000; // ËΩ¨Êç¢‰∏∫ÊØ´Áßí
    } catch (error) {
      console.error('Ëß£ÊûêtokenÂ§±Ë¥•:', error);
      return 0;
    }
  };

  // Ê∏ÖÈô§ËÆ§ËØÅÊï∞ÊçÆ
  const clearAuthData = () => {
    localStorage.removeItem('auth_token');
    localStorage.removeItem('refresh_token');
    localStorage.removeItem('user_data');
    localStorage.removeItem('remember_me');
    localStorage.removeItem('session_id');
    setUser(null);
    setError(null);

    if (refreshTimer) {
      clearTimeout(refreshTimer);
      setRefreshTimer(null);
    }
  };

  useEffect(() => {
    // Ê£ÄÊü•Êú¨Âú∞Â≠òÂÇ®‰∏≠ÁöÑÁî®Êà∑‰ø°ÊÅØÂπ∂È™åËØÅtoken
    const checkAuth = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const refreshTokenValue = localStorage.getItem('refresh_token');
        const userData = localStorage.getItem('user_data');
        const rememberMe = localStorage.getItem('remember_me') === 'true';

        if (token && userData) {
          try {
            // Ëß£ÊûêÁî®Êà∑Êï∞ÊçÆ
            const user = JSON.parse(userData);

            // Ê£ÄÊü•tokenÊòØÂê¶Âç≥Â∞ÜËøáÊúü
            const expiryTime = parseTokenExpiry(token);
            const currentTime = Date.now();

            if (expiryTime > currentTime) {
              // Token‰ªçÁÑ∂ÊúâÊïàÔºåÁõ¥Êé•ËÆæÁΩÆÁî®Êà∑Áä∂ÊÄÅ
              setUser(user);

              // ËÆæÁΩÆËá™Âä®Âà∑Êñ∞
              if (rememberMe && refreshTokenValue) {
                setupTokenRefresh(expiryTime - currentTime);
              }

              console.log('‚úÖ ‰ªélocalStorageÊÅ¢Â§çÁî®Êà∑ÁôªÂΩïÁä∂ÊÄÅ:', user.email);
            } else if (rememberMe && refreshTokenValue) {
              // TokenËøáÊúü‰ΩÜÊúârefresh tokenÔºåÂ∞ùËØïÂà∑Êñ∞
              try {
                await refreshToken();
              } catch (error) {
                throw new Error('TokenÂà∑Êñ∞Â§±Ë¥•');
              }
            } else {
              throw new Error('TokenÂ∑≤ËøáÊúü');
            }
          } catch (parseError) {
            console.error('‚ùå Ëß£ÊûêÁî®Êà∑Êï∞ÊçÆÂ§±Ë¥•:', parseError);
            throw new Error('Áî®Êà∑Êï∞ÊçÆÊ†ºÂºèÈîôËØØ');
          }
        }
      } catch (error) {
        console.error('‚ùå ËÆ§ËØÅÊ£ÄÊü•Â§±Ë¥•:', error);
        // Ê∏ÖÈô§Êó†ÊïàÁöÑËÆ§ËØÅ‰ø°ÊÅØ
        clearAuthData();
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();

    // Ê∏ÖÁêÜÂÆöÊó∂Âô®
    return () => {
      if (refreshTimer) {
        clearTimeout(refreshTimer);
      }
    };
  }, []);

  const login = async (credentials: LoginCredentials) => {
    const { email, password, rememberMe = false } = credentials;

    // È™åËØÅÂøÖÂ°´Â≠óÊÆµ
    if (!email || !password) {
      throw new Error('ÈÇÆÁÆ±ÂíåÂØÜÁ†ÅÈÉΩÊòØÂøÖÂ°´ÁöÑ');
    }

    setIsLoading(true);
    try {
      // ÂáÜÂ§áËØ∑Ê±ÇÊï∞ÊçÆ
      const requestData = {
        email,
        password,
        rememberMe
      };

      console.log('üîç ÂèëÈÄÅÁôªÂΩïËØ∑Ê±Ç:', {
        url: 'http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/login',
        data: { ...requestData, password: '***' } // ÈöêËóèÂØÜÁ†Å
      });

      // Ë∞ÉÁî®ÁôªÂΩïAPI
      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
      });

      const result = await response.json();

        status: response.status,
        ok: response.ok,
        result: result
      });

      if (!response.ok) {
        console.error('‚ùå ÁôªÂΩïËØ∑Ê±ÇÂ§±Ë¥•:', {
          status: response.status,
          statusText: response.statusText,
          result: result
        });
        throw new Error(result.message || 'ÁôªÂΩïÂ§±Ë¥•');
      }

      // Ê£ÄÊü•ÁôªÂΩïÊòØÂê¶ÊàêÂäü
      if (!result.success) {
        throw new Error(result.message || 'ÁôªÂΩïÂ§±Ë¥•');
      }

      // Ëé∑ÂèñÂìçÂ∫îÊï∞ÊçÆ
      const { data } = result;
      if (!data || !data.user) {
        throw new Error('ÁôªÂΩïÂìçÂ∫îÊ†ºÂºèÈîôËØØ');
      }

      // ‰øùÂ≠òtokenÂíåÁî®Êà∑‰ø°ÊÅØ
      localStorage.setItem('auth_token', data.accessToken);
      localStorage.setItem('refresh_token', data.refreshToken);
      localStorage.setItem('user_data', JSON.stringify(data.user));
      localStorage.setItem('remember_me', rememberMe.toString());

      setUser(data.user);

      // Â¶ÇÊûúÈÄâÊã©ËÆ∞‰ΩèÁôªÂΩïÁä∂ÊÄÅÔºåËÆæÁΩÆËá™Âä®Âà∑Êñ∞
      if (rememberMe && data.refreshToken) {
        const expiryTime = parseTokenExpiry(data.accessToken);
        const currentTime = Date.now();
        if (expiryTime > currentTime) {
          setupTokenRefresh(expiryTime - currentTime);
        }
      }

      console.log('‚úÖ ÁôªÂΩïÊàêÂäü:', data.user.email);

    } catch (error: any) {
      console.error('‚ùå ÁôªÂΩïÂ§±Ë¥•:', error);

      // Ëß£ÊûêÂπ∂ËÆæÁΩÆÈîôËØØ
      const errorType = parseAuthError(error);
      setError(errorType);

      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const register = async (data: RegisterData) => {
    const { username, email, password, confirmPassword } = data;
    setIsLoading(true);
    try {
      // Ë∞ÉÁî®ÁúüÂÆûÁöÑÊ≥®ÂÜåAPI
      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, email, password, confirmPassword }),
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.message || 'Ê≥®ÂÜåÂ§±Ë¥•');
      }

      // Ê£ÄÊü•Ê≥®ÂÜåÊòØÂê¶ÊàêÂäü
      if (!result.success) {
        throw new Error(result.message || 'Ê≥®ÂÜåÂ§±Ë¥•');
      }

      // Ëé∑ÂèñÂìçÂ∫îÊï∞ÊçÆ
      const { data } = result;
      if (!data || !data.user) {
        throw new Error('Ê≥®ÂÜåÂìçÂ∫îÊ†ºÂºèÈîôËØØ');
      }

      // ‰øùÂ≠òtokenÂíåÁî®Êà∑‰ø°ÊÅØ
      localStorage.setItem('auth_token', data.accessToken);
      localStorage.setItem('refresh_token', data.refreshToken);
      localStorage.setItem('user_data', JSON.stringify(data.user));

      setUser(data.user);

      console.log('‚úÖ Ê≥®ÂÜåÊàêÂäü:', data.user.email);

    } catch (error) {
      console.error('‚ùå Ê≥®ÂÜåÂ§±Ë¥•:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      const token = localStorage.getItem('auth_token');

      // Ë∞ÉÁî®ÁúüÂÆûÁöÑÁôªÂá∫API
      if (token) {
        await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/logout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`,
          },
        });
      }
    } catch (error) {
      console.error('‚ùå ÁôªÂá∫APIË∞ÉÁî®Â§±Ë¥•:', error);
      // Âç≥‰ΩøAPIË∞ÉÁî®Â§±Ë¥•Ôºå‰πüË¶ÅÊ∏ÖÈô§Êú¨Âú∞Â≠òÂÇ®
    } finally {
      // Ê∏ÖÈô§ËÆ§ËØÅÊï∞ÊçÆ
      clearAuthData();
      console.log('‚úÖ Áî®Êà∑Â∑≤ÁôªÂá∫');
    }
  };

  // Ê∑ªÂä†Áº∫Â§±ÁöÑÊñπÊ≥ï
  const updateProfile = async (data: any) => {
    try {
      const token = localStorage.getItem('auth_token');

      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/user/profile', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'Êõ¥Êñ∞ËµÑÊñôÂ§±Ë¥•');
      }

      // Êõ¥Êñ∞Êú¨Âú∞Áî®Êà∑Êï∞ÊçÆ
      if (result.user) {
        setUser(result.user);
        localStorage.setItem('user_data', JSON.stringify(result.user));
      }

      console.log('‚úÖ Áî®Êà∑ËµÑÊñôÊõ¥Êñ∞ÊàêÂäü');
    } catch (error) {
      console.error('‚ùå Êõ¥Êñ∞Áî®Êà∑ËµÑÊñôÂ§±Ë¥•:', error);
      throw error;
    }
  };

  const changePassword = async (data: any) => {
    try {
      const token = localStorage.getItem('auth_token');

      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/change-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || '‰øÆÊîπÂØÜÁ†ÅÂ§±Ë¥•');
      }

      console.log('‚úÖ ÂØÜÁ†Å‰øÆÊîπÊàêÂäü');
    } catch (error) {
      console.error('‚ùå ‰øÆÊîπÂØÜÁ†ÅÂ§±Ë¥•:', error);
      throw error;
    }
  };

  const forgotPassword = async (email: string) => {
    try {
      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/forgot-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email }),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'ÂèëÈÄÅÈáçÁΩÆÈÇÆ‰ª∂Â§±Ë¥•');
      }

      console.log('‚úÖ ÈáçÁΩÆÈÇÆ‰ª∂ÂèëÈÄÅÊàêÂäü');
      return result;
    } catch (error) {
      console.error('‚ùå ÂèëÈÄÅÈáçÁΩÆÈÇÆ‰ª∂Â§±Ë¥•:', error);
      throw error;
    }
  };

  const resetPassword = async (token: string, newPassword: string, confirmPassword: string) => {
    try {
      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/reset-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ token, newPassword, confirmPassword }),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'ÈáçÁΩÆÂØÜÁ†ÅÂ§±Ë¥•');
      }

      console.log('‚úÖ ÂØÜÁ†ÅÈáçÁΩÆÊàêÂäü');
      return result;
    } catch (error) {
      console.error('‚ùå ÈáçÁΩÆÂØÜÁ†ÅÂ§±Ë¥•:', error);
      throw error;
    }
  };

  const sendEmailVerification = async () => {
    try {
      const token = localStorage.getItem('auth_token');

      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/send-verification', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'ÂèëÈÄÅÈ™åËØÅÈÇÆ‰ª∂Â§±Ë¥•');
      }

      console.log('‚úÖ È™åËØÅÈÇÆ‰ª∂ÂèëÈÄÅÊàêÂäü');
      return result;
    } catch (error) {
      console.error('‚ùå ÂèëÈÄÅÈ™åËØÅÈÇÆ‰ª∂Â§±Ë¥•:', error);
      throw error;
    }
  };

  const verifyEmail = async (token: string) => {
    try {
      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/verify-email', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ token }),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'ÈÇÆÁÆ±È™åËØÅÂ§±Ë¥•');
      }

      // Êõ¥Êñ∞Áî®Êà∑Áä∂ÊÄÅ
      if (user) {
        const updatedUser = { ...user, emailVerified: true };
        setUser(updatedUser);
        localStorage.setItem('user_data', JSON.stringify(updatedUser));
      }

      console.log('‚úÖ ÈÇÆÁÆ±È™åËØÅÊàêÂäü');
      return result;
    } catch (error) {
      console.error('‚ùå ÈÇÆÁÆ±È™åËØÅÂ§±Ë¥•:', error);
      throw error;
    }
  };

  const refreshToken = async () => {
    try {
      const refreshTokenValue = localStorage.getItem('refresh_token');

      if (!refreshTokenValue) {
        throw new Error('Ê≤°ÊúâÂà∑Êñ∞‰ª§Áâå');
      }

      const response = await fetch('http://${process.env.BACKEND_HOST || 'localhost'}:${process.env.BACKEND_PORT || 3001}/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          refreshToken: refreshTokenValue
        }),
      });

      const result = await response.json();

      if (!response.ok || !result.success) {
        throw new Error(result.message || 'Âà∑Êñ∞‰ª§ÁâåÂ§±Ë¥•');
      }

      // Êõ¥Êñ∞Â≠òÂÇ®ÁöÑtoken
      const newToken = result.token || result.accessToken;
      localStorage.setItem('auth_token', newToken);

      if (result.refreshToken) {
        localStorage.setItem('refresh_token', result.refreshToken);
      }

      if (result.user) {
        localStorage.setItem('user_data', JSON.stringify(result.user));
        setUser(result.user);
      }

      // ËÆæÁΩÆ‰∏ãÊ¨°Ëá™Âä®Âà∑Êñ∞
      const rememberMe = localStorage.getItem('remember_me') === 'true';
      if (rememberMe) {
        const expiryTime = parseTokenExpiry(newToken);
        const currentTime = Date.now();
        if (expiryTime > currentTime) {
          setupTokenRefresh(expiryTime - currentTime);
        }
      }

      console.log('‚úÖ TokenÂà∑Êñ∞ÊàêÂäü');
    } catch (error) {
      console.error('‚ùå TokenÂà∑Êñ∞Â§±Ë¥•:', error);
      // Âà∑Êñ∞Â§±Ë¥•ÔºåÊ∏ÖÈô§ËÆ§ËØÅÊï∞ÊçÆ
      clearAuthData();
      throw error;
    }
  };

  const hasPermission = (permission: string): boolean => {
    return user?.permissions?.includes(permission) || false;
  };

  const hasRole = (role: string): boolean => {
    return user?.role === role;
  };

  const hasAnyRole = (roles: string[]): boolean => {
    return roles.some(role => user?.role === role);
  };

  const clearError = () => {
    setError(null);
  };

  const value: AuthContextType = {
    user,
    isLoading,
    login,
    register,
    logout,
    updateProfile,
    changePassword,
    refreshToken,
    hasPermission,
    hasRole,
    hasAnyRole,
    clearError,
    forgotPassword,
    resetPassword,
    sendEmailVerification,
    verifyEmail,
    isAuthenticated: !!user,
    isAdmin: user?.role === 'admin',
    error
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
