/**
 * ÂëäË≠¶ËßÑÂàôÂºïÊìé
 * Ë¥üË¥£ËßÑÂàôËØÑ‰º∞„ÄÅÊù°‰ª∂Ê£ÄÊü•ÂíåÂëäË≠¶Ëß¶Âèë
 * Version: 1.0
 */

const logger = require('../../utils/logger');
const { query } = require('../../config/database');

class AlertRuleEngine {
  constructor() {
    this.rules = new Map();
    this.cooldowns = new Map(); // ÂÜ∑Âç¥ÊúüÁÆ°ÁêÜ
    this.evaluationHistory = new Map(); // ËØÑ‰º∞ÂéÜÂè≤
    this.initialized = false;
  }

  /**
   * ÂàùÂßãÂåñËßÑÂàôÂºïÊìé
   */
  async initialize() {
    try {
      logger.info('üöÄ ÂàùÂßãÂåñÂëäË≠¶ËßÑÂàôÂºïÊìé...');
      
      // ‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÊ¥ªË∑ÉËßÑÂàô
      await this.loadRulesFromDatabase();
      
      // ÂêØÂä®ÂÆöÊúüÊ∏ÖÁêÜ
      this.startCleanupTask();
      
      this.initialized = true;
      logger.info('‚úÖ ÂëäË≠¶ËßÑÂàôÂºïÊìéÂàùÂßãÂåñÂÆåÊàê', {
        rulesCount: this.rules.size
      });
      
      return true;
    } catch (error) {
      logger.error('ÂëäË≠¶ËßÑÂàôÂºïÊìéÂàùÂßãÂåñÂ§±Ë¥•', error);
      return false;
    }
  }

  /**
   * ‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩËßÑÂàô
   */
  async loadRulesFromDatabase() {
    try {
      const result = await query(
        `SELECT * FROM alert_rules WHERE is_active = true ORDER BY created_at DESC`
      );
      
      for (const row of result.rows) {
        this.rules.set(row.id, {
          id: row.id,
          name: row.name,
          description: row.description,
          metricName: row.metric_name,
          condition: row.condition,
          threshold: parseFloat(row.threshold),
          severity: row.severity,
          channels: row.channels,
          cooldown: row.cooldown || 300, // ÈªòËÆ§5ÂàÜÈíü
          isActive: row.is_active,
          createdBy: row.created_by,
          createdAt: row.created_at
        });
      }
      
      logger.info(`‚úÖ Âä†ËΩΩ‰∫Ü ${result.rows.length} Êù°ÂëäË≠¶ËßÑÂàô`);
    } catch (error) {
      logger.error('Âä†ËΩΩÂëäË≠¶ËßÑÂàôÂ§±Ë¥•', error);
      throw error;
    }
  }

  /**
   * Ê∑ªÂä†ËßÑÂàô
   */
  async addRule(rule) {
    try {
      // È™åËØÅËßÑÂàô
      this.validateRule(rule);
      
      // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
      const result = await query(
        `INSERT INTO alert_rules 
         (id, name, description, metric_name, condition, threshold, severity, channels, cooldown, is_active, created_by)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
         RETURNING *`,
        [
          rule.id || require('uuid').v4(),
          rule.name,
          rule.description || null,
          rule.metricName,
          rule.condition,
          rule.threshold,
          rule.severity || 'medium',
          JSON.stringify(rule.channels || ['email']),
          rule.cooldown || 300,
          rule.isActive !== false,
          rule.createdBy || null
        ]
      );
      
      const savedRule = result.rows[0];
      
      // Ê∑ªÂä†Âà∞ÂÜÖÂ≠ò
      this.rules.set(savedRule.id, {
        id: savedRule.id,
        name: savedRule.name,
        description: savedRule.description,
        metricName: savedRule.metric_name,
        condition: savedRule.condition,
        threshold: parseFloat(savedRule.threshold),
        severity: savedRule.severity,
        channels: savedRule.channels,
        cooldown: savedRule.cooldown,
        isActive: savedRule.is_active,
        createdBy: savedRule.created_by,
        createdAt: savedRule.created_at
      });
      
      logger.info('‚úÖ Ê∑ªÂä†ÂëäË≠¶ËßÑÂàô', { ruleId: savedRule.id, name: rule.name });
      
      return savedRule;
    } catch (error) {
      logger.error('Ê∑ªÂä†ÂëäË≠¶ËßÑÂàôÂ§±Ë¥•', error, { rule });
      throw error;
    }
  }

  /**
   * Êõ¥Êñ∞ËßÑÂàô
   */
  async updateRule(ruleId, updates) {
    try {
      const rule = this.rules.get(ruleId);
      if (!rule) {
        throw new Error(`ËßÑÂàô‰∏çÂ≠òÂú®: ${ruleId}`);
      }
      
      // ÊûÑÂª∫Êõ¥Êñ∞ËØ≠Âè•
      const fields = [];
      const values = [];
      let paramIndex = 1;
      
      if (updates.name !== undefined) {
        fields.push(`name = $${paramIndex++}`);
        values.push(updates.name);
      }
      if (updates.description !== undefined) {
        fields.push(`description = $${paramIndex++}`);
        values.push(updates.description);
      }
      if (updates.threshold !== undefined) {
        fields.push(`threshold = $${paramIndex++}`);
        values.push(updates.threshold);
      }
      if (updates.severity !== undefined) {
        fields.push(`severity = $${paramIndex++}`);
        values.push(updates.severity);
      }
      if (updates.channels !== undefined) {
        fields.push(`channels = $${paramIndex++}`);
        values.push(JSON.stringify(updates.channels));
      }
      if (updates.cooldown !== undefined) {
        fields.push(`cooldown = $${paramIndex++}`);
        values.push(updates.cooldown);
      }
      if (updates.isActive !== undefined) {
        fields.push(`is_active = $${paramIndex++}`);
        values.push(updates.isActive);
      }
      
      if (fields.length === 0) {
        return rule;
      }
      
      values.push(ruleId);
      
      const result = await query(
        `UPDATE alert_rules SET ${fields.join(', ')}, updated_at = NOW() WHERE id = $${paramIndex} RETURNING *`,
        values
      );
      
      // Êõ¥Êñ∞ÂÜÖÂ≠ò‰∏≠ÁöÑËßÑÂàô
      await this.loadRulesFromDatabase();
      
      logger.info('‚úÖ Êõ¥Êñ∞ÂëäË≠¶ËßÑÂàô', { ruleId, updates });
      
      return result.rows[0];
    } catch (error) {
      logger.error('Êõ¥Êñ∞ÂëäË≠¶ËßÑÂàôÂ§±Ë¥•', error, { ruleId, updates });
      throw error;
    }
  }

  /**
   * Âà†Èô§ËßÑÂàô
   */
  async deleteRule(ruleId) {
    try {
      await query('DELETE FROM alert_rules WHERE id = $1', [ruleId]);
      this.rules.delete(ruleId);
      this.cooldowns.delete(ruleId);
      
      logger.info('‚úÖ Âà†Èô§ÂëäË≠¶ËßÑÂàô', { ruleId });
      
      return true;
    } catch (error) {
      logger.error('Âà†Èô§ÂëäË≠¶ËßÑÂàôÂ§±Ë¥•', error, { ruleId });
      throw error;
    }
  }

  /**
   * ËØÑ‰º∞ÊåáÊ†áÊòØÂê¶Ëß¶ÂèëÂëäË≠¶
   */
  async evaluate(metric) {
    try {
      const triggeredRules = [];
      
      // ÈÅçÂéÜÊâÄÊúâËßÑÂàô
      for (const [ruleId, rule] of this.rules) {
        // Ê£ÄÊü•ËßÑÂàôÊòØÂê¶ÊøÄÊ¥ª
        if (!rule.isActive) {
          continue;
        }
        
        // Ê£ÄÊü•ÊåáÊ†áÂêçÁß∞ÊòØÂê¶ÂåπÈÖç
        if (rule.metricName !== metric.name) {
          continue;
        }
        
        // Ê£ÄÊü•Êù°‰ª∂
        if (!this.checkCondition(metric, rule)) {
          continue;
        }
        
        // Ê£ÄÊü•ÂÜ∑Âç¥Êúü
        if (this.isInCooldown(ruleId)) {
          logger.debug('ËßÑÂàôÂú®ÂÜ∑Âç¥ÊúüÂÜÖÔºåË∑≥Ëøá', { ruleId, rule: rule.name });
          continue;
        }
        
        // Ëß¶ÂèëÂëäË≠¶
        triggeredRules.push(rule);
        
        // ËÆæÁΩÆÂÜ∑Âç¥Êúü
        this.setCooldown(ruleId, rule.cooldown);
        
        // ËÆ∞ÂΩïËØÑ‰º∞ÂéÜÂè≤
        this.recordEvaluation(ruleId, metric, true);
        
        logger.info('üö® ÂëäË≠¶ËßÑÂàôËß¶Âèë', {
          ruleId,
          ruleName: rule.name,
          metric: metric.name,
          value: metric.value,
          threshold: rule.threshold
        });
      }
      
      return triggeredRules;
    } catch (error) {
      logger.error('ËØÑ‰º∞ÂëäË≠¶ËßÑÂàôÂ§±Ë¥•', error, { metric });
      return [];
    }
  }

  /**
   * Ê£ÄÊü•Êù°‰ª∂
   */
  checkCondition(metric, rule) {
    const value = parseFloat(metric.value);
    const threshold = parseFloat(rule.threshold);
    
    switch (rule.condition) {
      case 'gt': // Â§ß‰∫é
      case '>':
        return value > threshold;
        
      case 'gte': // Â§ß‰∫éÁ≠â‰∫é
      case '>=':
        return value >= threshold;
        
      case 'lt': // Â∞è‰∫é
      case '<':
        return value < threshold;
        
      case 'lte': // Â∞è‰∫éÁ≠â‰∫é
      case '<=':
        return value <= threshold;
        
      case 'eq': // Á≠â‰∫é
      case '==':
        return value === threshold;
        
      case 'ne': // ‰∏çÁ≠â‰∫é
      case '!=':
        return value !== threshold;
        
      default:
        logger.warn('Êú™Áü•ÁöÑÊù°‰ª∂Á±ªÂûã', { condition: rule.condition });
        return false;
    }
  }

  /**
   * Ê£ÄÊü•ÊòØÂê¶Âú®ÂÜ∑Âç¥Êúü
   */
  isInCooldown(ruleId) {
    const cooldownEnd = this.cooldowns.get(ruleId);
    if (!cooldownEnd) {
      return false;
    }
    
    const now = Date.now();
    if (now < cooldownEnd) {
      return true;
    }
    
    // ÂÜ∑Âç¥ÊúüÂ∑≤ËøáÔºåÂà†Èô§ËÆ∞ÂΩï
    this.cooldowns.delete(ruleId);
    return false;
  }

  /**
   * ËÆæÁΩÆÂÜ∑Âç¥Êúü
   */
  setCooldown(ruleId, cooldownSeconds) {
    const cooldownEnd = Date.now() + (cooldownSeconds * 1000);
    this.cooldowns.set(ruleId, cooldownEnd);
    
    logger.debug('ËÆæÁΩÆÂëäË≠¶ÂÜ∑Âç¥Êúü', {
      ruleId,
      cooldownSeconds,
      cooldownEnd: new Date(cooldownEnd).toISOString()
    });
  }

  /**
   * ËÆ∞ÂΩïËØÑ‰º∞ÂéÜÂè≤
   */
  recordEvaluation(ruleId, metric, triggered) {
    const history = this.evaluationHistory.get(ruleId) || [];
    history.push({
      timestamp: Date.now(),
      metric,
      triggered
    });
    
    // Âè™‰øùÁïôÊúÄËøë100Êù°ËÆ∞ÂΩï
    if (history.length > 100) {
      history.shift();
    }
    
    this.evaluationHistory.set(ruleId, history);
  }

  /**
   * È™åËØÅËßÑÂàô
   */
  validateRule(rule) {
    if (!rule.name) {
      throw new Error('ËßÑÂàôÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫');
    }
    
    if (!rule.metricName) {
      throw new Error('ÊåáÊ†áÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫');
    }
    
    if (!rule.condition) {
      throw new Error('Êù°‰ª∂‰∏çËÉΩ‰∏∫Á©∫');
    }
    
    if (rule.threshold === undefined || rule.threshold === null) {
      throw new Error('ÈòàÂÄº‰∏çËÉΩ‰∏∫Á©∫');
    }
    
    const validConditions = ['gt', '>', 'gte', '>=', 'lt', '<', 'lte', '<=', 'eq', '==', 'ne', '!='];
    if (!validConditions.includes(rule.condition)) {
      throw new Error(`Êó†ÊïàÁöÑÊù°‰ª∂: ${rule.condition}`);
    }
    
    const validSeverities = ['low', 'medium', 'high', 'critical'];
    if (rule.severity && !validSeverities.includes(rule.severity)) {
      throw new Error(`Êó†ÊïàÁöÑ‰∏•ÈáçÁ®ãÂ∫¶: ${rule.severity}`);
    }
  }

  /**
   * Ëé∑ÂèñÊâÄÊúâËßÑÂàô
   */
  getRules() {
    return Array.from(this.rules.values());
  }

  /**
   * Ëé∑ÂèñÂçï‰∏™ËßÑÂàô
   */
  getRule(ruleId) {
    return this.rules.get(ruleId);
  }

  /**
   * Ëé∑ÂèñËßÑÂàôËØÑ‰º∞ÂéÜÂè≤
   */
  getEvaluationHistory(ruleId) {
    return this.evaluationHistory.get(ruleId) || [];
  }

  /**
   * ÂêØÂä®Ê∏ÖÁêÜ‰ªªÂä°
   */
  startCleanupTask() {
    // ÊØèÂ∞èÊó∂Ê∏ÖÁêÜ‰∏ÄÊ¨°ËøáÊúüÁöÑÂÜ∑Âç¥Êúü
    setInterval(() => {
      this.cleanupCooldowns();
    }, 3600000); // 1Â∞èÊó∂
  }

  /**
   * Ê∏ÖÁêÜËøáÊúüÁöÑÂÜ∑Âç¥Êúü
   */
  cleanupCooldowns() {
    const now = Date.now();
    let cleaned = 0;
    
    for (const [ruleId, cooldownEnd] of this.cooldowns) {
      if (now >= cooldownEnd) {
        this.cooldowns.delete(ruleId);
        cleaned++;
      }
    }
    
    if (cleaned > 0) {
      logger.info('Ê∏ÖÁêÜËøáÊúüÂÜ∑Âç¥Êúü', { count: cleaned });
    }
  }

  /**
   * Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ
   */
  getStats() {
    return {
      totalRules: this.rules.size,
      activeRules: Array.from(this.rules.values()).filter(r => r.isActive).length,
      rulesInCooldown: this.cooldowns.size,
      evaluationHistorySize: Array.from(this.evaluationHistory.values())
        .reduce((sum, history) => sum + history.length, 0)
    };
  }

  /**
   * ÂÖ≥Èó≠ÂºïÊìé
   */
  async close() {
    this.rules.clear();
    this.cooldowns.clear();
    this.evaluationHistory.clear();
    logger.info('‚úÖ ÂëäË≠¶ËßÑÂàôÂºïÊìéÂ∑≤ÂÖ≥Èó≠');
  }
}

// ÂØºÂá∫Âçï‰æã
let alertRuleEngineInstance = null;

function getAlertRuleEngine() {
  if (!alertRuleEngineInstance) {
    alertRuleEngineInstance = new AlertRuleEngine();
  }
  return alertRuleEngineInstance;
}

module.exports = AlertRuleEngine;
module.exports.getAlertRuleEngine = getAlertRuleEngine;

